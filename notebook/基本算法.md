基本算法

### 1 二叉树

- 前序遍历：栈

```java
递归三行，非递归用栈
List<Integer> preOrderTraversal(TreeNode root);
void travel(TreeNode root, List<Integer> res) 
    while(!stack.isEmpty()) 
        node = stack.poll()
        // 注意判null，栈的后进先出，此处要先入右节点，再左节点
        stack.push(node.right)
        stack.push(node.left)
        
```

* 中序遍历：栈+visited

```java
非递归用栈，visited记录节点是否被访问过，表示什么？如果该node节点的左节点已经放入到stack中，就加入进去。
    出栈：第二次遇到就出栈
    入栈：遇到就入栈
    入visited：
    出visited：
List<Integer> preOrderTraversal(TreeNode root);
	while(!stack.isEmpty())
        peek来看看是不是
        if 第一次遇到:
			把它的左节点入栈，把它加入visited
        else if 第二次遇到
            res.add(出栈)，并把右节点入栈
            同时可以移除visited中的对应节点
```

* 后续遍历：栈+visited

```java
非递归：栈+visited。
什么时候node放入在visited？当node的左右节点信息都存放到stack之后，就可以。
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        Set<TreeNode> visited = new HashSet<>();
        if (root == null){
            return res;
        }

        stack.addLast(root);
        while(!stack.isEmpty()) {
            // 左右节点的信息都存放到了stack中，就把它放入到visited中
            TreeNode node = stack.peekLast();
            if(!visited.contains(node) ) {
            	// 栈的特性，需要先入右节点，在入左节点。
                if(node.right!=null){
                    stack.addLast(node.right);
                } 
                if (node.left!=null) {
                    stack.addLast(node.left);
                }
                visited.add(node);
            } else {
                stack.removeLast();
                visited.remove(node);
                res.add(node.val);
            }
        }
        return res;

    }
```

* 层序遍历：宽度优先搜索（遍历所有的queue，进行扩散）
  * 遍历所有的queue，将当前层的队列的所有节点的子节点向四周扩散

### 2 排序

