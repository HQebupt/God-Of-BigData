## 为什么需要保证幂等性

编程中的“幂等性”是指任意多次执行所产生的影响，与一次执行的影响相同。一个拥有幂等性设计的接口，保证无论一次或多次来调用接口，都能够得到相同的结果。

> 接口的幂等性设计在某些场景下是必需的，例如用户下单的场景。

服务之间的调用存在三种状态：成功、失败、超时。超时是一种未知的状态：被调服务是否执行成功，这个状态是未知的。上游服务调用下游服务超时时可能会进行重试。



对于用户下单的场景的超时重试我们考虑以下问题：

- 是否会导致最终创建了两条一样的订单？
- 是否会扣除两遍库存？
- 是否会重复扣除用户的钱？

如果每一笔订单都携带唯一的序号，下单接口可以借助这个序号，来记录某次下单操作的状态。当下单的状态为成功时，就将重复的执行拦截住，避免出现上述的问题。这种方式是由下游被调方来保证幂等性。

除此之外，订单服务也可以提供查询订单状态的接口，上游在下单之前先进行查询，确认该笔订单并没有成功支付后，再重复进行下单操作。

> 一般来说，服务本身需要自己保证幂等性，而不应该将幂等性交给上游的调用方来做。

### 如何做幂等性设计

对于一个接口，如何做幂等性设计？

- 核心思想是利用唯一的ID来标识某一种操作，比如下单。
  - mysql自增ID可以实现
  - 分布式唯一ID可以实现
  - 前端可以利用token过滤一些不必要的重试操作

## **如何在分布式系统生成唯一的ID**

分布式系统中需要使用全局唯一ID的场景，为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先相对比较长，另外UUID一般是无序的。标准的UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128

我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。

#### **snowflake的结构**

长度是1个long型的数字，64位。**snowflake的结构如下(每部分用-分开):**

```
0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
```

- 第1位为未使用，
- 接下来的41位为毫秒级时间(41位的长度可以使用69年)，
- 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，
- 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）

> 一共加起来刚好64位，为一个Long型。(转换成字符串长度为18).
>
> snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。

Code : [snow flake](https://github.com/HQebupt/app/blob/master/src/main/java/design/SnowFlake.java)

