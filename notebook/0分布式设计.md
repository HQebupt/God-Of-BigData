## 分布式锁的实现

### 适用场景

- 库存超卖问题：用户下单之前，需要检查一下库存，库存足够了才会给用户下单。当库存=1，A和B同时来检查库存，然后下单，会出现超卖的情况。
- 某服务提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。

### 实现要求

- 可重入锁，可以避免死锁
- 阻塞锁，看业务情况
- 是否是高可用的
- 锁的获取和释放性能要好

### **ZooKeeper分布式锁的流程**

ZooKeeper，分布式协调服务

- 在zookeeper指定节点（locks）下创建临时顺序节点node_n
- 获取locks下所有子节点children
- 对子节点按节点自增序号从小到大排序
- 判断本节点是不是第一个子节点，若是，则获取锁；若不是，则监听比该节点小的那个节点的删除事件
- 若监听事件生效，则回到第二步重新进行判断，直到获取到锁

**具体实现**

- 通过实现Watch接口，实现process(WatchedEvent event)方法来实施监控，使CountDownLatch来完成监控，在等待锁的时候使用CountDownLatch来计数，等到后进行countDown，停止等待，继续运行。
- 以下整体流程基本与上述描述流程一致，只是在监听的时候使用的是CountDownLatch来监听前一个节点。



[DistributedLock](https://github.com/yangliu0/DistributedLock)

### Redis 实现分布式锁

~~简言之，利用Redis的SETNX，GETSET命令。~~



### Mysql实现分布式锁

简言之，可以利用mysql的索引的唯一性或者乐观锁。

### 对比

**数据库分布式锁实现**缺点：

- db操作性能较差，并且有锁表的风险
- 非阻塞操作失败后，需要轮询，占用cpu资源;
- 长时间不commit或者长时间轮询，可能会占用较多连接资源

**Redis(缓存)分布式锁实现**缺点：

- 锁删除失败 过期时间不好控制
- 非阻塞，操作失败后，需要轮询，占用cpu资源;

**ZK分布式锁实现**缺点：

- 性能不如redis实现，主要原因是写操作（获取锁释放锁）都需要在Leader上执行，然后同步到follower。

**总之：ZooKeeper有较好的性能和可靠性。**

- 从理解的难易程度角度（从低到高）数据库 > 缓存 > Zookeeper
- 从实现的复杂性角度（从低到高）Zookeeper >= 缓存 > 数据库
- 从性能角度（从高到低）缓存 > Zookeeper >= 数据库
  
