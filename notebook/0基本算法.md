基本算法

## 1 二叉树

- 前序遍历：栈

```java
递归三行，非递归用栈
List<Integer> preOrderTraversal(TreeNode root);
void travel(TreeNode root, List<Integer> res) 
    while(!stack.isEmpty()) 
        node = stack.poll()
        // 注意判null，栈的后进先出，此处要先入右节点，再左节点
        stack.push(node.right)
        stack.push(node.left)
        
```

* 中序遍历：栈+visited

```java
非递归用栈，visited记录节点是否被访问过，表示什么？如果该node节点的左节点已经放入到stack中，就加入进去。
    出栈：第二次遇到就出栈
    入栈：遇到就入栈
    入visited：
    出visited：
List<Integer> preOrderTraversal(TreeNode root);
	while(!stack.isEmpty())
        peek来看看是不是
        if 第一次遇到:
			把它的左节点入栈，把它加入visited
        else if 第二次遇到
            res.add(出栈)，并把右节点入栈
            同时可以移除visited中的对应节点
```

* 后续遍历：栈+visited

```java
非递归：栈+visited。
什么时候node放入在visited？当node的左右节点信息都存放到stack之后，就可以。
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        Set<TreeNode> visited = new HashSet<>();
        if (root == null){
            return res;
        }

        stack.addLast(root);
        while(!stack.isEmpty()) {
            // 左右节点的信息都存放到了stack中，就把它放入到visited中
            TreeNode node = stack.peekLast();
            if(!visited.contains(node) ) {
            	// 栈的特性，需要先入右节点，在入左节点。
                if(node.right!=null){
                    stack.addLast(node.right);
                } 
                if (node.left!=null) {
                    stack.addLast(node.left);
                }
                visited.add(node);
            } else {
                stack.removeLast();
                visited.remove(node);
                res.add(node.val);
            }
        }
        return res;

    }
```

* 层序遍历：宽度优先搜索（遍历所有的queue，进行扩散）
  * 遍历所有的queue，将当前层的队列的所有节点的子节点向四周扩散

### 判断树的子结构

- 判断Tree B是Tree A的子结构
- 递归的定义是什么？就是题目定义
- root做什么？
  - 如果rootA和rootB相等，就完全对比这两棵树
  - 如果不相等，就看看A的左子树能不能包含B；也看看A的右子树能不能包含B。

```java
		boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B == null) { return false;}
        return helper(A,B);
    }
		boolean helper(TreeNode a, TreeNode b) {
        // root 做什么
        boolean match = false;
        if (b == null) { return true;}
        if (a == null) { return false;}
        if (a.val == b.val) {
            match = isCompleteEqual(a, b);
        }
        if (!match) {
            match = helper(a.left, b) || helper(a.right, b);
        }
        return match;
    }
```

### 重建二叉树

- 前序遍历结果为[3, 9, 20, 15, 7]，可知root节点为3
- 中序为[9, 3, 15, 20, 7]，以3为中点将数组分拆为[9]和[15, 20, 7]两个子数组，则前者为左子树，后者为右子树
- 再找出前序的子树[9]和[20, 15, 7]，返回root节点。
- 套路如下：
  - 递归的定义是什么，相信它？输入是前序数组和中序数组，输出是构成这棵树的根节点
  - root做什么？构建左右子树。
  - 细节是什么？推算出左右子树的长度，然后计算前序和中序数组的左右范围。

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
        int len = preorder.length;
        return help(preorder,inorder, 0, len - 1, 0, len -1);
    }

    int findRoot(int[] inorder, int i1, int i2, int root) {
        for(int i = i1; i <= i2; i++) {
            if (root == inorder[i]) {
                return i;
            }
        }
        return -1;
    }
		
    TreeNode help(int[] preorder, int[] inorder, int p1, int p2, int i1, int i2) {
        if(p1 > p2|| i1 > i2) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[p1]);
        int ik = findRoot(inorder, i1, i2, preorder[p1]);
        int len = ik - i1;
      	// preorder的第一个数是root，子树是不包含root的。
        root.left = help(preorder, inorder, p1 + 1, p1 + len, i1, ik - 1);
        root.right = help(preorder, inorder, p1 + len + 1, p2, ik + 1, i2);
        return root;
    }
```

### 

## 2 排序

#### 快速排序

partition思想

```java
void qsort(int[] a, int lo, int hi) {
  if (lo >= hi) return;
  int q = partition(a, lo, hi);
  qsort(a, lo, q - 1);
  qsort(a, q + 1, hi);
}

int partition(int[] a, int lo, int hi) {
  int x = a[lo];
  int i = lo, j = hi + 1;
  while(i < j) {
    while(a[--j] > x){}
    while(a[++i] < x) {判断越界}
    if (i >= j) {
      break;
    }
    swap(a, i , j);
  }
  swap(a, lo, j);
  return j;
}
```

三向切分: 

- 对数组划成三等分[... lt,...,gt,....]，index小于lt的，都小于x；index大于gt的，都大于x。
- 适用于有大量重复元素的排序
- 算法：根据a[i] 与 v的值进行比较，判断如何移动指针。

![image-20210628110807333](0基本算法.assets/image-20210628110807333-1624849688857.png)

> 关键是记牢：lt和gt的位置，从切分后的图像中记忆。
>
> 初始值怎么设置：x, lt, gt, i

```java
	void sort3p(int[]a, int lo, int hi){
        if(lo >= hi) {
            return;
        }
        int x = a[lo], lt = lo, gt = hi, i = lo + 1; // i的初始值随意：i=lo，也可以
        while(i <= gt) {
            if (x == a[i]) {
                i++;
            } else if (x > a[i]) {
                swap(a, lt, i);
                i++;
                lt++;
            } else if(x < a[i]) {
                swap(a, i, gt);
                gt--;
            }
        }

        sort3p(a, lo, lt - 1); // 左边排序
        sort3p(a, gt + 1, hi); // 右边排序
    }
```



#### 堆排序

- 二叉堆：堆顶大就是大顶堆。

- node: ~~0~~ 1 2 3 4 

  - index = 0的位置空着 ，方便计算parent和child
  - index = i，`parent = i/2; 左子=i*2; 右子=i*2 + 1`

- 操作：

  - 上浮swim 和 下沉 sink
  - 二叉堆添加元数在堆底，swim；删除元素在堆顶 ，然后移动堆底元素到堆顶，sink。

- 堆排的步骤：构建大顶堆，index=0,1,2,3,4。 

  - index因为从0开始，所有`parent =(i-1)/2; 左子=i*2 + 1;右子=i*2 +2`
  - 利用swim构建堆，从0-length `swim(int[] a, int k)` （parent比k大，就交换）
  - 交换0和最后一个元素，sink来调整堆，直到堆中元素为0.`sink(int[] a, int k ,int size)` （左右节点的最大值 比k大，就交换）

  ```java
  void heapSort(int[] a){
      int len = a.length;
      // swim创建最大堆
      for(int i = 0; i < len; i++) {
          swim(a, i);
      }
  
      int size = len;
      // swap 和 sink出队，排序 
      while(size>0) {
          swap(a, 0, --size);
          sink(a, 0, size);
      }
  }
  
  // swim创建最大堆：parent比k小，就交换
  void swim(int[] a, int k) {
      int p = parent(k);
      while(less(a, p, k)) {
          swap(a, p, k);
          k = p;
          p = parent(k);
      }
  }
  // 左右节点的最大值 比k大，就交换
  void sink(int[] a, int k, int size) {
      int left = leftChild(k) >= size ? k : leftChild(k);
      int right = rightChild(k) >= size ? k : rightChild(k);
      int max = less(a, left, right) ? right : left;
      if(!less(a, k, max)) {
          return;
      }
      swap(a, k, max);
      sink(a, max, size);
  }
  ```

#### 归并排序

- 分治思想，自顶向下的思路步骤：

  - 将数组二分，再递归将分出来的子数组二分
  - 直到子数组长度为1时，递归退出，将二分的子数组合并
    - 合并过程中需要申请一段辅助空间aux用于临时存储排序后的值
    - 将合并、排序好的辅助空间数据拷贝到原数组上
  - 当递归不断返回后，排序即完成

  ![image-20210603145820771](0基本算法.assets/image-20210603145820771.png)

  
  
  
  
- 自底向上的思路
  - 从batch size = 1,2,4... 开始，每2个batch进行合并一次。batch的最大值选取可以是len，也可以是len - 1
  
  - 每2个batch在内部进行有序合并，确定好merge(lo, mid, hi)
  
    ![image-20210603171656783](0基本算法.assets/image-20210603171656783-1622711818392.png)
  
    - lo 是起始位置 i
    - mid = lo + batch - 1 (最大值< len - 1)
    - hi = lo + batch + batch - 1
  
  ```java
  // 4-1 归并排序-自顶向下
  // 先分解到最小单元
  // 在合并
  void mergeSort1(int[] a, int lo, int hi) {
      if (lo >= hi) {
          return;
      }
      int mid = lo + (hi - lo) / 2;
      mergeSort1(a, lo, mid);
      mergeSort1(a, mid + 1, hi);
      merge(a, lo, mid, hi);
  }
  
  // 4-2 归并排序-自底向上
  // 从batch size = 1,2,4... 开始，每2个batch进行合并一次
  // 每2个batch在内部进行有序合并
  void mergeSort2(int[] a, int lo, int hi) {
      if (lo >= hi) {
          return;
      }
      int len = hi - lo + 1;
      for (int sz = 1; sz < len; sz = sz + sz) { // batch sz的最大值可以是len，也可以是len - 1
          for (int i = lo; i < len - sz; i = i + sz + sz) { // mid < len - 1 推出i的范围
              int mid = i + sz - 1;
              int j = Math.min(i + sz + sz - 1, hi); // 小心越界
              merge(a, i, mid, j);
          }
      }
  }
  
  
  // 开发一个merge 合并有序数组a, lo -- mid; mid + 1, hi;
  void merge(int[] a, int lo, int mid, int hi) {
      // 1 辅助数组aux
      // 2 合并有序数组
      // 3 拷贝aux到原数组
      int size = hi - lo + 1;
      int[] aux = new int[size];
  
      int i = lo, j = mid + 1, k = 0;
      while( i <= mid && j <= hi) {
          if(less(a[i],a[j])) {
              aux[k++] = a[i++];
          } else {
              aux[k++] = a[j++];
          }
      }
      while(i<= mid) {
          aux[k++] = a[i++];
      }
      while(j <= mid) {
          aux[k++] = a[j++];
      }
      // copy
      System.arraycopy(aux,0,a, lo, size);
  }
  ```
  
  

## 3 链表

### 从尾到头打印链表

- 思路：使用栈的后进先出，或者直接用递归

### 在O(1)时间删除链表节点

- 一般方法：根据val查找这个节点，用前后指针（双指针）跟着走。`prev.next = cur.next`来删除cur。
- O(1): 要删除Node(n)，直接用Node(n+1)的val复制给Node(n)，然后直接删除Node(n+1)

 ```java
   void deleteNode(ListNode node) {
       ListNode nex = node.next;
       if (nex != null) {
           node.val = nex.val;
           node.next = nex.next;
       } else {
           node = null;
       }
   }
 ```



## 4 字符串

###  删除字符串中的所有相邻重复项 II

- 递归删除字符串中出现的k次相邻的重复项。输入s = "deeedbbcccbdaa", k = 3，输出 "aa"

- 暴力解法：不断从头遍历s，知道s没有需要删除的字符

- stack: 括号匹配的思路变形，用Pair记录字符，以及出现的次数，然后次数达到k之后，删除。

  ```java
      public String removeDuplicates(String s, int k) {
          int len = s.length();
          LinkedList<Pair> stack = new LinkedList<>();
          for (int i = 0; i < len; i++) {
              char ch = s.charAt(i);
              if (stack.isEmpty()) { // 栈空，直接入栈i
                  stack.addLast(new Pair(ch, 1));
                  continue;
              }
              Pair pair = null;
              if ((pair = stack.peekLast()).ch != ch) { //ch 与栈顶不一致，直接入栈i
                  stack.addLast(new Pair(ch, 1)); 
              } else if ((++pair.count) == k) // 栈顶达到k个元素，直接出栈删除
                  stack.removeLast();
              }
          }
          // 从stack构造输出
      }
  ```




## 3 数组

### 有序二维数组的查找

- 有序数组用二分，时间复杂度M*log(N), M是行数，N是列数

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
		for(int i = 0; i < matrix.length; i++) {
			if(find(matrix[i], 0, matrix[i].length - 1, target)) {
				return true;
			}
		}
		return false;
	}

	boolean find(int[]a, int lo, int hi, int num) {
		while(lo <= hi) { // 标准的二分查找，判断条件 lo<=hi
			int mid = lo + (hi - lo) / 2;
			if (a[mid] == num) {
				return true;
			} else if (a[mid] > num) {
				hi = mid - 1;
			} else if (a[mid] < num) {
				lo = mid + 1;
			}
		}
		return false;
	}
```

### 旋转数组的最小数字

> 二分查找细节是魔鬼

### 二进制中1的个数

- n&(n-1) 可以消除二进制n中的最后一位1

```java
    int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
    }
```

### 调整数组顺序使奇数位于偶数前面

- 一般的思路是遍历查找、插入、挪位，时间复杂度O(n^2)
- 快排 partition 思路：可用两个指针分别指向数组头尾，头指针负责搜索偶数，尾指针负责搜索奇数，然后将头尾的值交换，再继续执行以上操作，直到头尾指针相遇

```java
   int[] exchange(int[] nums) {
        int p = 0, q = nums.length - 1; // p 搜索偶数，q搜索奇数
        int len = nums.length;
        while (p < q) {
            while (p < len && !isOu(nums[p])) { p++;}
            while (q >= 0 && isOu(nums[q])) { q--;}
            if (p >= q) { break;}
            swap(nums, p, q);
        }
        return nums;
    }
```



## 3 DP

### 连续子数组和最大

- dp+压缩空间
  - base case
  - 状态：数组长度 => 一定包含位置i的数组的最大和
  - 选择：要不要加入dp[i-1]
  - dp 方程：`dp[i] = max(dp[i - 1] + a[i - 1], a[i - 1])`

```java
	int maxSubArray(int[] nums) {
        int max = nums[0];
        int local = max;
        for (int i = 1; i < nums.length; i++) {
            local = Math.max(nums[i], local + nums[i]);
            max = Math.max(local, max);
        }
        return max;
    }
```

### 连续子数组和绝对值最大

动态规划思路：题目是求绝对值最大值，显然需要知道连续数组的最大最小值。可以遍历2次数组，来求出连续子数组和最大值和最小值。然后再次遍历2个dp数组，求出绝对值最大的值。

比如对于求连续子数组的最大和，参考上面的dp思路。

```java	
		int maxAbsoluteSum(int[] nums) {
        int local = 0, max = 0, localMin = 0, min = 0;
        for (int num : nums) {
            local = Math.max(local + num, num);
            localMin = Math.min(localMin + num, num);
            max = Math.max(local, max);
            min = Math.min(localMin, min);
        }
        return Math.max(Math.abs(min), Math.abs(max));
    }
```

### 连续子数组乘积最大

- 动态规划，因为乘积会变成负值，所以要记录最小\最大值。最后，空间压缩。
- maxV[i]: 包含i的最大乘积值
- minV[i]: 包含i的最小乘积值

| index | 0    | 1    | 2    | 3    |
| :---: | ---- | ---- | ---- | ---- |
|       | 2    | 3    | -2   | 4    |
| maxV  | 2    | 6    | -2   | 4    |
| minV  | 2    | 3    | -12  | -48  |

```java	
	int maxProduct(int[] nums) {
        int res = Integer.MIN_VALUE, minV = 1, maxV = 1;
        for(int num : nums) {
            int tmpMin = minV;
            int a = num;
            int b = num * minV;
            int c = num * maxV;
            minV = min(a,b,c);
            b = num * tmpMin;
            maxV = max(a, b, c);
            res = Math.max(res, maxV);
        }
        return res;
    }
```

## 其他

### 两个栈实现队列

队列是先进先出，栈是后进先出。可以用2个stack来模拟

- 第一个pushStack 用来入队
- 第二个popStack用来出队，当popStack中没有元素时，就把pushStack移动过来。

### 斐波那契数列

- F(n) = F(n - 1) + F(n - 2),    F(0) = 0, F(1) = 1
- 动态规划的感觉，注意题目要求对结果取mod

```java
 int fib(int n) {
        int e9 = 1000000007;
        int fn2 = 0, fn1 = 1, fn = 0;
        if (n <=1) {
            return n;
        }
        for(int i = 2; i <= n; i++) {
            fn = (fn2 + fn1) % e9;
            fn2 = fn1;
            fn1 = fn;
        }
        return (int)fn % e9;
    }
```

### 最多可以参加的会议数目

关键：对于某一天day，能够在这天参加的所有会议中，到底应该选哪一个来参加。（这就是贪心，每一天总是选取结束时间最早的会议参加，局部贪心，最后达到全局最优。）

核心就是要解决优先级队列的优先级的定义。明白入队和出队的时机

- 对于某一天day, 需要把能够参加这天的所有会议入队，
- 然后选取结束时间最早的出队，进行判断，能否在这天参加会议
  - 如果能，就把能够参加次数+1
  - 如果不能，就需要连续出队，尽量找到1个可以参加的会议

```java
	int maxEvents(int[][] events) {
        int len = events.length;
        Arrays.sort(events,(a,b)->{return a[0] - b[0];}); // sort by startDay
        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->{
            return a[1] - b[1];
        }); // 结束时间最早的排在前面。

        int day = 1, i = 0, times = 0;
        while(i < len || !queue.isEmpty()) {
            // 入队
            while(i< len && events[i][0] == day) {
                queue.offer(events[i]);
                i++;
            }
            // 出队
            while(!queue.isEmpty()) {
                int[] item = queue.poll();
                if(valid(day, item)) {
                    times++;
                    break;
                }
            }
            // 更新day到下一天
            day++;
        }
        return times;
    }
```

## 

