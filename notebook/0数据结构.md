## 1 跳表

> 为什么Redis一定要用跳表来实现有序集合？

跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。

- 有序链表上面增加了多级索引，通过索引来实现快速查找\删除\添加。
- 查找删除添加的时间复杂度O(logN)

![图片](0数据结构.assets/640-4090246.png)



- 对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.

- 在插入的时候是否添加上层索引是个概率问题(1/2的概率)

  ```java
  // 基本节点
  class SkipNode<T>
  {
      int key;
      T value;
      SkipNode next,down;//右下个方向的指针
      public SkipNode (int key,T value) {
          this.key=key;
          this.value=value;
      }
  }
  ```

初始化将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。

### 查询

从最上层，只要找到一个就可以了，不用找到最底层去。

<img src="0数据结构.assets/640-20210619162319931-4091001.png" alt="图片" style="zoom:50%;" />



### 删除

(1)删除当前节点和这个节点的前后节点都有关系

(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层

(3) 因此，查找左节点的方式来删除。因为跳表的结构决定了，如果上层有节点7，下面一层一定有节点7。

> 注意红色部分的数字，就是删除的逻辑。

<img src="0数据结构.assets/640-4092914." alt="图片" style="zoom:67%;" />

### 添加

**插入需要考虑是否插入索引，插入几层**等问题。**如何找到上层的待插入节点** ？（**巧妙的借助查询过程中记录下降的节点**）

- 从最底层添加，根据随机函数决定是否往上添加节点

* 利用stack来存储搜索的路径，每次只需要记录向下↓的节点，这样可以追溯往上添加node的路径。
  1. 搜索左节点阶段，stack存放每次向下↓的节点，方便以后在这些节点之后，添加新的节点。
  2. 添加节点阶段，根据stack和随机函数，从底层向上层，添加节点。
     - 注意：如果添加节点的level数大于了最大的32，则停止向上添加
     - 如果添加节点的level数已经大于了当前跳表的最大层数，需要更新头结点head

<img src="0数据结构.assets/640-20210620161350447-4176837." alt="图片" style="zoom:67%;" />



如果遇到到了第3层，仍然判断要往上添加索引节点，则需要更新head节点？



<img src="0数据结构.assets/640-20210620161446255-4176887." alt="图片" style="zoom:67%;" />

### 总结

对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，**它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。**而JDK中**跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。** 有兴趣的也可以查阅一下源码。

```java

/**
 * Leetcode 1206
 * 跳表的结构：给多级链表加上索引，每层索引都是最底层Node的copy。
 * 查找：从最上层，只要找到一个就可以了，不用找到最底层去。
 * 删除：需要删除每层出现的所有节点，所有找到待删除节点的左节点，然后执行删除。
 * 添加：从最底层添加，根据随机函数决定是否往上添加节点
 */
public class Skiplist {
    static class SkipNode {
        int key;
        int value;
        SkipNode next, down;

        public SkipNode(int key) {
            this(key, Integer.MIN_VALUE);
        }

        public SkipNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    SkipNode head; // 头结点
    Random random; // 随机数，控制插入
    int highLevel; // 当前链表的层数
    final int MAX_HIGH_LEVEL = 32;

    public Skiplist() {
        head = new SkipNode(Integer.MIN_VALUE);
        random = new Random();
        highLevel = 0;
    }

    // 查询：为了统一思想，查找节点的部分也用查找左节点的思想。
    // key > cur: 需要根据cur.next 与 key比较，觉得是向↓还是向→走
    //            cur.next == null: 只能往下↓
    //            key < cur.next: 往下↓
    //            key == cur.next: 找到了，可以不走了。
    //            key > cur.next: 往右→
    public boolean search(int key) {
        SkipNode cur = head;
        SkipNode found = null;
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                cur = cur.down;
            } else if (key == cur.next.key) {
                found = cur;
                break;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }
        return found == null ? false : true;
    }

    // 删除：查找左节点
    //    cur.next不存在：往下↓搜索
    //    key < cur.next: 往下↓搜索
    //    key == cur.next: 找到了，执行删除。同时往↓走，继续删除下一层的key
    //    key > cur.next: 往右→搜索
    public boolean erase(int key) {
        SkipNode cur = head;
        boolean res = false;
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                cur = cur.down;
            } else if (key == cur.next.key) { // 查找到左节点，执行删除。同时往↓走，继续删除下一层的key
                cur.next = cur.next.next;
                cur = cur.down;
                res = true;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }
        return res;
    }

    /**
     * 添加节点：从最底层添加，根据随机函数决定是否往上添加节点。
     * 利用stack来存储搜索的路径，每次只需要记录向下↓的节点，这样可以追溯往上添加node的路径。
     * 如何处理？
     * 1. 搜索左节点阶段，stack存放每次向下↓的节点，方便以后在这些节点之后，添加新的节点。
     * 2. 添加节点阶段，根据stack和随机函数，从底层向上层，添加节点。
     * - 注意：如果添加节点的level数大于了最大的32，则停止向上添加
     * - 如果添加节点的level数已经大于了当前跳表的最大层数，需要更新头结点head
     */
    public void add(int key) {
        SkipNode cur = head;
        // 1 搜索左节点
        LinkedList<SkipNode> stack = new LinkedList<>();
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                stack.addLast(cur);
                cur = cur.down;
            } else if (key == cur.next.key) {
                stack.addLast(cur);
                cur = cur.down;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }

        // 2 添加节点
        int level = 0;
        SkipNode lastNode = null;
        while (!stack.isEmpty()) {
            cur = stack.removeLast();
            SkipNode node = new SkipNode(key);
            node.next = cur.next;
            cur.next = node;
            level++;
            node.down = lastNode;
            lastNode = node;

            double upRate = random.nextDouble();
            if (upRate > 0.5) { // 有1/2的概率向上添加节点
                return;
            }
            // 向上添加节点
            if (level > MAX_HIGH_LEVEL) {
                return;
            }
            if (level >= this.highLevel) {
                SkipNode newHead = new SkipNode(Integer.MIN_VALUE);
                newHead.down = head;
                head = newHead;
                stack.addLast(head);
                this.highLevel++;
            }
        }
    }
}

```

## 2 红黑树

**我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。**

由来：**红黑树是一种近似平衡二叉查找树**。它是为了解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

特性：红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。

适用场景：因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，我们其实更倾向用跳表来替代它。

<img src="0数据结构.assets/image-20210621091603697-4238165.png" alt="image-20210621091603697" style="zoom: 50%;" />

> 补充： AVL 树，严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。

### **一棵红黑树满足4个条件**

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

为了画图方便，省略掉了最后一层的叶子节点。

<img src="0数据结构.assets/image-20210621091914904-4238356.png" alt="image-20210621091914904" style="zoom:50%;" />

### 自平衡

<img src="0数据结构.assets/image-20210621092336054-4238618.png" alt="image-20210621092336054" style="zoom:50%;" />

- 左旋：围绕某个节点向左旋转。以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变

![img](0数据结构.assets/121304-4238508.png)

- 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变

![img](0数据结构.assets/121306-4238520.png)

- 变色：结点的颜色由红变黑或由黑变红

### 插入操作的平衡调整

**红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**。

> 对于红黑树的调整，推到正确性很难。就像魔方复原一样，什么样的case，做什么样的操作，就可以还原。所以不用记忆，翻看笔记就可以了。

关于插入操作的平衡调整，有这样两种特殊情况，但是也都非常好处理。

- 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
- 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。
- 除此之外，其他有3种情况都会违背红黑树的定义，需要调整（旋转和变色）

红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作**关注节点**。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。

> 为了简化描述，我把父节点的兄弟节点叫作叔叔节点，父节点的父节点叫作祖父节点。

**CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色**，我们就依次执行下面的操作：

- 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；
- 将关注节点 a 的祖父节点 c 的颜色设置成红色；
- 关注节点变成 a 的祖父节点 c；
- 跳到 CASE 2 或者 CASE 3。

<img src="0数据结构.assets/image-20210621093137897-4239099.png" alt="image-20210621093137897" style="zoom:50%;" />

**CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点**，我们就依次执行下面的操作：

- 关注节点变成节点 a 的父节点 b；
- 围绕新的关注节点b 左旋；
- 跳到 CASE 3。

<img src="0数据结构.assets/image-20210621093212385-4239133.png" alt="image-20210621093212385" style="zoom:50%;" />

**CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点**，我们就依次执行下面的操作：

- 围绕关注节点 a 的祖父节点 c 右旋；
- 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。
- 调整结束。

<img src="0数据结构.assets/image-20210621093254685-4239176.png" alt="image-20210621093254685" style="zoom: 50%;" />

### 删除的平衡调整

依旧只需要根据关注节点与周围节点的排布特点，按照一定的规则去调整就行了。

- 第一步是**针对删除节点初步调整**。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求
- 第二步是**针对关注节点进行二次调整**，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。

### 总结

第一点，**把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性**。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。

第二点，**找准关注节点，不要搞丢、搞错关注节点**。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。

第三点，**插入操作的平衡调整比较简单，但是删除操作就比较复杂**。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。

Java里面红黑树的定义，来自TreeMap.

```java
static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;
        Entry<K,V> right;
        Entry<K,V> parent;
        boolean color = BLACK;
}
```

