## 1 跳表

> 为什么Redis一定要用跳表来实现有序集合？

跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。

- 有序链表上面增加了多级索引，通过索引来实现快速查找\删除\添加。
- 查找删除添加的时间复杂度O(logN)

![图片](0数据结构.assets/640-4090246.png)



- 对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.

- 在插入的时候是否添加上层索引是个概率问题(1/2的概率)

  ```java
  // 基本节点
  class SkipNode<T>
  {
      int key;
      T value;
      SkipNode next,down;//右下个方向的指针
      public SkipNode (int key,T value) {
          this.key=key;
          this.value=value;
      }
  }
  ```

初始化将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。

### 查询

从最上层，只要找到一个就可以了，不用找到最底层去。

<img src="0数据结构.assets/640-20210619162319931-4091001.png" alt="图片" style="zoom:50%;" />



### 删除

(1)删除当前节点和这个节点的前后节点都有关系

(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层

(3) 因此，查找左节点的方式来删除。因为跳表的结构决定了，如果上层有节点7，下面一层一定有节点7。

> 注意红色部分的数字，就是删除的逻辑。

<img src="0数据结构.assets/640-4092914." alt="图片" style="zoom:67%;" />

### 添加

**插入需要考虑是否插入索引，插入几层**等问题。**如何找到上层的待插入节点** ？（**巧妙的借助查询过程中记录下降的节点**）

- 从最底层添加，根据随机函数决定是否往上添加节点

* 利用stack来存储搜索的路径，每次只需要记录向下↓的节点，这样可以追溯往上添加node的路径。
  1. 搜索左节点阶段，stack存放每次向下↓的节点，方便以后在这些节点之后，添加新的节点。
  2. 添加节点阶段，根据stack和随机函数，从底层向上层，添加节点。
     - 注意：如果添加节点的level数大于了最大的32，则停止向上添加
     - 如果添加节点的level数已经大于了当前跳表的最大层数，需要更新头结点head

<img src="0数据结构.assets/640-20210620161350447-4176837." alt="图片" style="zoom:67%;" />



如果遇到到了第3层，仍然判断要往上添加索引节点，则需要更新head节点？



<img src="0数据结构.assets/640-20210620161446255-4176887." alt="图片" style="zoom:67%;" />

### 总结

对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，**它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。**而JDK中**跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。** 有兴趣的也可以查阅一下源码。

```java

/**
 * Leetcode 1206
 * 跳表的结构：给多级链表加上索引，每层索引都是最底层Node的copy。
 * 查找：从最上层，只要找到一个就可以了，不用找到最底层去。
 * 删除：需要删除每层出现的所有节点，所有找到待删除节点的左节点，然后执行删除。
 * 添加：从最底层添加，根据随机函数决定是否往上添加节点
 */
public class Skiplist {
    static class SkipNode {
        int key;
        int value;
        SkipNode next, down;

        public SkipNode(int key) {
            this(key, Integer.MIN_VALUE);
        }

        public SkipNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    SkipNode head; // 头结点
    Random random; // 随机数，控制插入
    int highLevel; // 当前链表的层数
    final int MAX_HIGH_LEVEL = 32;

    public Skiplist() {
        head = new SkipNode(Integer.MIN_VALUE);
        random = new Random();
        highLevel = 0;
    }

    // 查询：为了统一思想，查找节点的部分也用查找左节点的思想。
    // key > cur: 需要根据cur.next 与 key比较，觉得是向↓还是向→走
    //            cur.next == null: 只能往下↓
    //            key < cur.next: 往下↓
    //            key == cur.next: 找到了，可以不走了。
    //            key > cur.next: 往右→
    public boolean search(int key) {
        SkipNode cur = head;
        SkipNode found = null;
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                cur = cur.down;
            } else if (key == cur.next.key) {
                found = cur;
                break;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }
        return found == null ? false : true;
    }

    // 删除：查找左节点
    //    cur.next不存在：往下↓搜索
    //    key < cur.next: 往下↓搜索
    //    key == cur.next: 找到了，执行删除。同时往↓走，继续删除下一层的key
    //    key > cur.next: 往右→搜索
    public boolean erase(int key) {
        SkipNode cur = head;
        boolean res = false;
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                cur = cur.down;
            } else if (key == cur.next.key) { // 查找到左节点，执行删除。同时往↓走，继续删除下一层的key
                cur.next = cur.next.next;
                cur = cur.down;
                res = true;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }
        return res;
    }

    /**
     * 添加节点：从最底层添加，根据随机函数决定是否往上添加节点。
     * 利用stack来存储搜索的路径，每次只需要记录向下↓的节点，这样可以追溯往上添加node的路径。
     * 如何处理？
     * 1. 搜索左节点阶段，stack存放每次向下↓的节点，方便以后在这些节点之后，添加新的节点。
     * 2. 添加节点阶段，根据stack和随机函数，从底层向上层，添加节点。
     * - 注意：如果添加节点的level数大于了最大的32，则停止向上添加
     * - 如果添加节点的level数已经大于了当前跳表的最大层数，需要更新头结点head
     */
    public void add(int key) {
        SkipNode cur = head;
        // 1 搜索左节点
        LinkedList<SkipNode> stack = new LinkedList<>();
        while (cur != null && key > cur.key) {
            if (cur.next == null || key < cur.next.key) {
                stack.addLast(cur);
                cur = cur.down;
            } else if (key == cur.next.key) {
                stack.addLast(cur);
                cur = cur.down;
            } else if (key > cur.next.key) {
                cur = cur.next;
            }
        }

        // 2 添加节点
        int level = 0;
        SkipNode lastNode = null;
        while (!stack.isEmpty()) {
            cur = stack.removeLast();
            SkipNode node = new SkipNode(key);
            node.next = cur.next;
            cur.next = node;
            level++;
            node.down = lastNode;
            lastNode = node;

            double upRate = random.nextDouble();
            if (upRate > 0.5) { // 有1/2的概率向上添加节点
                return;
            }
            // 向上添加节点
            if (level > MAX_HIGH_LEVEL) {
                return;
            }
            if (level >= this.highLevel) {
                SkipNode newHead = new SkipNode(Integer.MIN_VALUE);
                newHead.down = head;
                head = newHead;
                stack.addLast(head);
                this.highLevel++;
            }
        }
    }
}

```

