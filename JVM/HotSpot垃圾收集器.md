# HotSpot垃圾收集器

HotSpot 虚拟机提供了多种垃圾收集器，每种收集器都有各自的特点，虽然我们要对各个收集器进行比较，但并非为了挑选出一个最好的收集器。我们选择的只是对具体应用最合适的收集器。

- CMS和G1回收的过程，从响应和吞吐量来看，G1有什么优势？
- G1解决了什么问题？说一说详细的内部过程？

## 1新生代垃圾收集器

### 1.1Serial 垃圾收集器（单线程）

只开启**一条** GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程\(Stop The World\)。

一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器**适合客户端**使用。

由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。 
![3f94897d49934c0d10fcf641f2ea9398](HotSpot垃圾收集器.resources/9790224E-BF78-4E47-A73D-94EC5845A554.png)

### 1.2ParNew 垃圾收集器（多线程）


ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。

ParNew 追求“**低停顿时间**”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但**线程切换需要额外的开销**，因此在单 CPU 环境中表现不如 Serial。

![03e2a048077b12ff86e8e71c51d0e2c8](HotSpot垃圾收集器.resources/B8252EDC-045D-4565-AAF7-64C729EDE03D.png)


### 1.3Parallel Scavenge 垃圾收集器（多线程）

Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：

* Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。
* ParNew：追求降低用户停顿时间，适合交互式应用。

吞吐量 = 运行用户代码时间 / \(运行用户代码时间 + 垃圾收集时间\)

追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。

* 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。
* 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。
* 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。

## 2老年代垃圾收集器

### 2.1Serial Old 垃圾收集器（单线程）

Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。

### 2.2Parallel Old 垃圾收集器（多线程）

Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。

### 2.3CMS 垃圾收集器

CMS\(Concurrent Mark Sweep，并发标记清除\)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。

* 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
* 并发标记：使用**多条**标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。
* 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。
* 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。

并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，**总体上说**，CMS 收集器的内存回收过程是与用户线程**一起并发执行**的。

![a7a96aa9e9e60973b3a0cc3e92c6e2bb](HotSpot垃圾收集器.resources/1238D175-FF81-4F5A-8899-CCA09DCCD5D9.png)

CMS 的缺点：

* 吞吐量低
* 无法处理浮动垃圾，导致频繁 Full GC
* 使用“标记-清除”算法产生碎片空间

对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。

### 2.4 G1 通用垃圾收集器

G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。

从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

这里抛个问题👇

> 一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？

并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。（Remembered Set解决了我指向谁，谁指向我的问题。）

如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤：

* 初始标记（Initial Marking)：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。

* 并发标记(Concurrent Marking)：使用**一条**标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。此外，当 对象 图 扫描 完成 以后， 还要 重新 处理 SATB 记 录下 的 在 并发 时有 引用 变动 的 对象。

  周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） (华章原创精品) (Kindle Locations 2529-2530). 北京华章图文信息有限公司. Kindle Edition. 

* 最终标记（Final Marking）：Stop The World，对用户线程做另外一个短暂的暂停，来处理并发标记阶段结束后，人人遗留下来的最后的少量的SATB记录。

* 筛选回收（Live Data Counting and Evacuation）：统计Region数据，对它们的回收价值和成本排序，根据 用户 所 期望 的 停顿 时间 来 制定 回收 计划， 可以 自由选择 任意 多个 Region 构成 回收 集（Collection Set， 一般 简称 CSet）， 然后 把 决定 回收 的 那一 部分 Region 的 存活 对象 复制 到 空的 Region 中， 再 清理 掉 整 个旧 Region 的 全部 空间。 这里 的 操作 涉及 存活 对象 的 移动， 是 必须 暂停 用户 线程， 由 多条 收集 器 线程 并行 完成 的。。



![image-20210531144923362](HotSpot垃圾收集器.assets/image-20210531144923362-1622443765429.png)

它可 以 面向 堆 内存 任何 部分 来 组成 回收 集（ Collection Set， 一般 简称 CSet） 进行 回收， 衡量 标准 不再 是它 属于 哪个 分 代， 而是 哪 块 内存 中 存放 的 垃圾 数量 最多， 回收 收益 最大， 这就 是 G1 收集 器 的 Mixed GC 模式。

差异： G1 不再 坚持 固定 大小 以及 固定 数量 的 分 代 区域 划分， 而是 把 连续 的 Java 堆 划分 为多 个大 小 相等 的 独立 区域（ Region）， 每一个 Region 都可以 根据 需要， 扮演 新生代 的 Eden 空间、 Survivor 空间， 或者 老年 代 空间。

Region 中 还有 一类 特殊 的 Humongous 区域， 专门 用来 存储 大 对象。 G1 认为 只要 大小 超过 了 一个 Region 容量 一半 的。 每个Region 的 大小 可以 通过 参数- XX： G1HeapRegionSize 设定， 取值 范围 为 1MB ～ 32MB，

![image-20210531142500045](HotSpot垃圾收集器.assets/image-20210531142500045-1622442301631.png)

使用 参数- XX： MaxGCPauseMillis 指定， 默认值 是 200 毫秒），一般来说， 回收 阶段 占到 几十 到 一百 甚至 接 近两 百 毫秒 都很 正常，实际中，设置100-300ms比较正常。



常见问题：

1. 将 Java 堆 分成 多个 独立 Region 后， Region 里面 存 在的 跨 Region 引用 对象 如何 解决？Remember Set（“ 卡 表”（ Card Table） 的 方式 去 实现 记忆 集)

2. 在 并发 标记 阶段 如何 保证 收集 线程 与 用户 线程 互不 干扰 地 运行？节）： CMS 收集 器 采用 增量 更新 算法 实现， 而 G1 收集 器 则是 通过 原始 快照（ SATB） 算法 来 实现 的。

3. 怎样 建立 起 可靠 的 停顿 预测 模型？ 用户 通过- XX： MaxGCPauseMillis 参数 指定 的 停顿 时间 只 意味着 垃圾 收集 发生 之前 的 期望 值， 但 G1 收集 器 要 怎么 做 才能 满足 用户 的 期望 呢？ G1 收集 器 的 停顿 预测 模型 是以 衰减 均值（Decaying Average）为理论基础。

4. 如果G1设置的停顿时间过短，比如20ms，会发生什么？ G1每次回收的时候，会在筛选回收阶段，选择那些内存小的回收集合来进行回收，这样的问题就是刚开始还能够保证停顿时间，一旦对象分配的速度大于了垃圾回收的速度，就会导致垃圾堆积，最后导致堆被暂满，引起Full GC，反而降低了性能。

   



### 2.5 G1 和 CMS对比

G1优点很多，基础的就有：可以指定最大停顿时间、分Region的内存布局、按照收益动态确定回收集。从算法理论来看，

- G1是基于标记整理思想的，不会产生内存空间碎片

CMS是不是一无是处呢

- CMS 算法没有那么复杂，内存占用（Footprint)和负载(overload) 要低一些
  - 内存：都用Card Table(Remember Set) 来解决跨代指向的问题，G1更复杂，更耗费内存
  - 负载：都用到了写屏障，CMS和G1都用写后屏障来维护卡表，而G1的TATB还用了写前屏障。（ 相比 起 增量 更新 算法， 原始 快照 搜索 能够 减少 并发 标记 和 重新 标记 阶段 的 消耗， 避免 CMS 那样 在最 终 标记 阶段 停顿 时间 过长 的 缺点， 但是 在用 户 程序 运行 过程中 确实 会 产生 由 跟踪 引用 变化 带来 的 额外负担。 由于 G1 对 写 屏障 的 复杂 操作 要比 CMS 消耗 更多 的 运算 资源， 所以 CMS 的 写屏 障 实现 是 直接 的 同步 操作， 而 G1 就不 得不 将其 实现 为 类似于 消息 队列 的 结构， 把 写 前 屏障 和 写 后 屏障 中 要做 的 事情 都 放到 队列 里， 然后 再 异步 处理。）

> 按照 笔者 的 实践经验， 目前 在 小 内存 应用 上 CMS 的 表现 大概 率 仍然 要 会 优于 G1， 而在 大内 存 应用 上 G1 则 大多 能 发挥 其 优势， 这个 优 劣势 的 Java 堆 容量 平衡 点 通常 在 6GB 至 8GB 之间，
>